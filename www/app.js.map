{
  "version": 3,
  "sources": ["../src/Connection.ts", "../src/MicButton.ts", "../src/index.ts"],
  "sourcesContent": ["export class Connection {\n  private audioEl: HTMLAudioElement;\n  private pc: RTCPeerConnection;\n  private dc: RTCDataChannel;\n  private micTrack: MediaStreamTrack;\n  private eventListeners: Map<string, (data: any) => void>;\n\n  constructor(\n    audioElement: HTMLAudioElement,\n    peerConnection: RTCPeerConnection,\n    dataChannel: RTCDataChannel,\n    micTrack: MediaStreamTrack\n  ) {\n    this.audioEl = audioElement;\n    this.pc = peerConnection;\n    this.dc = dataChannel;\n    this.micTrack = micTrack;\n    this.eventListeners = new Map();\n\n    // Set up data channel message handling\n    this.dc.addEventListener(\"message\", (e) => {\n      // Notify all registered event listeners\n      const data = e.data;\n      // console.log(\"Received event:\", data);\n\n      // Dispatch event to all registered handlers\n      this.eventListeners.forEach((callback) => {\n        callback(data);\n      });\n    });\n  }\n\n  // Cleanup method to terminate the connection\n  close(): void {\n    console.log(\"Closing WebRTC connection\");\n    // Clean up tracks\n    if (this.micTrack) {\n      this.micTrack.stop();\n    }\n    // Close data channel\n    if (this.dc) {\n      this.dc.close();\n    }\n    // Close peer connection\n    if (this.pc) {\n      this.pc.close();\n    }\n  }\n\n  // Volume property (0.0 - 1.0)\n  get volume(): number {\n    return this.audioEl.volume;\n  }\n\n  set volume(value: number) {\n    this.audioEl.volume = Math.max(0, Math.min(1, value));\n  }\n\n  // Speaker muted property\n  get audioMuted(): boolean {\n    return this.audioEl.muted;\n  }\n\n  set audioMuted(value: boolean) {\n    this.audioEl.muted = value;\n  }\n\n  // Microphone muted property\n  get micMuted(): boolean {\n    return !this.micTrack.enabled;\n  }\n\n  set micMuted(value: boolean) {\n    this.micTrack.enabled = !value;\n  }\n\n  // Data channel method\n  send(event: any): void {\n    console.log(\"Sending event:\", event);\n    this.dc.send(JSON.stringify(event));\n  }\n\n  addEventListener(id: string, callback: (data: any) => void): void {\n    this.eventListeners.set(id, callback);\n  }\n\n  removeEventListener(id: string): void {\n    this.eventListeners.delete(id);\n  }\n\n  // Expose elements for advanced use cases\n  getAudioElement(): HTMLAudioElement {\n    return this.audioEl;\n  }\n\n  getPeerConnection(): RTCPeerConnection {\n    return this.pc;\n  }\n\n  getDataChannel(): RTCDataChannel {\n    return this.dc;\n  }\n\n  getMicrophoneTrack(): MediaStreamTrack {\n    return this.micTrack;\n  }\n}", "/**\n * MicButton - Abstracts microphone button state management\n * \n * Manages state for mute/unmute and push-to-talk functionality\n */\nexport class MicButton {\n  // Constants\n  static readonly HOLD_DELAY = 200; // ms to differentiate between click and hold\n\n  // State\n  private muted: boolean = true;\n  private holdTimeout: number | null = null;\n  private pushToTalkActive: boolean = false;\n  private suppressNextClick: boolean = false;\n\n  // DOM elements\n  private element: HTMLElement;\n\n  constructor(\n    element: HTMLElement,\n    private onMuteChange: (muted: boolean) => void\n  ) {\n    this.element = element;\n\n    // Add event handlers\n    this.element.addEventListener(\"mousedown\", () => this.startPress());\n    this.element.addEventListener(\"touchstart\", () => this.startPress());\n    this.element.ownerDocument.addEventListener(\"keydown\", (e) => {\n      if (e.key === \" \" && !e.repeat) {\n        e.preventDefault(); // Prevent page scrolling\n        this.startPress();\n      }\n    });\n\n    this.element.addEventListener(\"mouseup\", () => this.endPress());\n    this.element.addEventListener(\"touchend\", () => this.endPress());\n    this.element.ownerDocument.addEventListener(\"keyup\", (e) => {\n      if (e.key === \" \") {\n        this.endPress();\n      }\n    });\n\n    this.element.addEventListener(\"click\", (e) => this.onClick(e));\n  }\n\n  /**\n   * Getters & Setters\n   */\n  public isMuted(): boolean {\n    return this.muted;\n  }\n\n  public isPushToTalkActive(): boolean {\n    return this.pushToTalkActive;\n  }\n\n  public setMuted(muted: boolean): void {\n    if (this.muted === muted) return;\n\n    this.muted = muted;\n    this.onMuteChange(muted);\n  }\n\n  /**\n   * Push-to-talk methods. Call these only when we are sure the user is holding\n   * the button or key down, not a momentary click/press.\n   */\n  public startPushToTalk(): void {\n    this.pushToTalkActive = true;\n    this.setMuted(false);\n  }\n\n  public stopPushToTalk(): void {\n    if (this.pushToTalkActive) {\n      this.pushToTalkActive = false;\n      this.setMuted(true);\n    }\n  }\n\n  /**\n   * Toggle mute/unmute state\n   */\n  public toggle(): void {\n    this.setMuted(!this.muted);\n  }\n\n  /**\n   * Begin the gesture that may turn out to be a click (toggle), or may turn out\n   * to be a hold (push-to-talk).\n   *\n   * It's the same logic for mouse, touch, and space key.\n   */\n  private startPress(): void {\n    // Do nothing at first--we don't know if it's a click or hold\n    this.holdTimeout = window.setTimeout(() => {\n      this.startPushToTalk();\n      this.holdTimeout = null;\n    }, MicButton.HOLD_DELAY);\n  }\n\n  /**\n   * End the gesture that may have been a click or a hold.\n   */\n  private endPress(): void {\n    this.suppressNextClick = true;\n    window.setTimeout(() => {\n      this.suppressNextClick = false;\n    }, 0);\n\n    if (this.holdTimeout) {\n      // It was a click\n      clearTimeout(this.holdTimeout);\n      this.holdTimeout = null;\n      this.toggle();\n    } else {\n      // It was a hold\n      this.stopPushToTalk();\n    }\n  }\n\n  /**\n   * We generally don't need this; it's only for programmatic clicks (e.g. from\n   * screen readers, or possibly JS). We suppress it if it was preceded by a\n   * mousedown/touchstart/keydown because we would've already performed the\n   * desired action then.\n   */\n  private onClick(e: MouseEvent): void {\n    if (this.suppressNextClick) {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n      return;\n    }\n    this.toggle();\n  }\n}\n", "import \"./binding\";\nimport { Connection } from \"./Connection\";\nimport { MicButton } from \"./MicButton\";\nimport \"./styles.css\";\n\nexport async function openConnection(ephemeralKey: string, model: string) {\n  // Create a peer connection\n  const pc = new RTCPeerConnection();\n\n  // Set up to play remote audio from the model\n  const audioEl = document.createElement(\"audio\");\n  audioEl.autoplay = true;\n\n  pc.ontrack = (e) => (audioEl.srcObject = e.streams[0]);\n\n  // Add local audio track for microphone input in the browser\n  const ms = await navigator.mediaDevices.getUserMedia({\n    audio: true,\n  });\n  const micTrack = ms.getTracks()[0];\n  pc.addTrack(micTrack);\n  micTrack.enabled = false; // Start with mic muted\n\n  // Set up data channel for sending and receiving events\n  const dc = pc.createDataChannel(\"oai-events\");\n\n  // Start the session using the Session Description Protocol (SDP)\n  const offer = await pc.createOffer();\n  await pc.setLocalDescription(offer);\n\n  const baseUrl = \"https://api.openai.com/v1/realtime/calls\";\n  const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {\n    method: \"POST\",\n    body: offer.sdp,\n    headers: {\n      Authorization: `Bearer ${ephemeralKey}`,\n      \"Content-Type\": \"application/sdp\",\n    },\n  });\n\n  const answer: RTCSessionDescriptionInit = {\n    type: \"answer\",\n    sdp: await sdpResponse.text(),\n  };\n  await pc.setRemoteDescription(answer);\n\n  // Create and return the connection instance\n  return new Connection(audioEl, pc, dc, micTrack);\n}\n\n// Custom Shiny output binding for real-time display\nclass RealtimeBinding extends Shiny.OutputBinding {\n  find(scope) {\n    return $(scope).find(\".shinyrealtime\");\n  }\n\n  renderValue(el, data) {\n    const id = this.getId(el);\n\n    // Store connection in element data for cleanup\n    const { key, model } = JSON.parse(data);\n    let connectionPromise = openConnection(key, model).then((connection) => {\n      $(document).on(\"shiny:disconnected\", function () {\n        console.log(\"Shiny disconnected, cleaning up any WebRTC connections\");\n        connection.close();\n      });\n\n      // MicButton implementation has been moved to MicButton.ts\n\n      // Create the mic button controller\n      const micButtonElement = el.querySelector(\n        \".mic-toggle-btn\"\n      ) as HTMLElement;\n      const micButton = new MicButton(micButtonElement, (muted: boolean) => {\n        // This is our callback when mic state changes\n        connection.micMuted = muted;\n\n        if (muted) {\n          micButtonElement.classList.remove(\"active\", \"btn-danger\");\n          micButtonElement.classList.add(\"btn-secondary\");\n        } else {\n          micButtonElement.classList.remove(\"btn-secondary\");\n          micButtonElement.classList.add(\"active\", \"btn-danger\");\n        }\n      });\n\n      $(el).data(\"rtConnection\", connection);\n\n      // Set up Shiny-specific event handling\n      connection.addEventListener(\"shiny\", (data) => {\n        Shiny.setInputValue(id + \"_event\", data, { priority: \"event\" });\n      });\n\n      // Set up message handler for sending events from Shiny\n      Shiny.addCustomMessageHandler(\"realtime_send\", (events) => {\n        events.forEach((event) => connection.send(event));\n      });\n\n      return connection;\n    });\n  }\n\n  // Clean up connection when element is removed/updated\n  unsubscribe(el) {\n    const connection = $(el).data(\"rtConnection\");\n    if (connection && typeof connection.close === \"function\") {\n      console.log(\"Closing WebRTC connection due to element unsubscribe\");\n      connection.close();\n    }\n  }\n}\n\n// Register the binding\nShiny.outputBindings.register(new RealtimeBinding(), \"realtime-output\");\n\n// Plays audio elements, identified by CSS selector\nShiny.addCustomMessageHandler(\n  \"play_audio\",\n  ({ selector }: { selector: string }) => {\n    const audioEl = document.querySelector(selector) as HTMLAudioElement;\n    if (audioEl) {\n      audioEl.currentTime = 0;\n      audioEl.play().catch((err) => {\n        console.error(\"Error playing audio:\", err);\n      });\n    } else {\n      console.error(\"Audio element not found for selector:\", selector);\n    }\n  }\n);"],
  "mappings": "mBAAO,IAAMA,EAAN,KAAiB,CAOtB,YACEC,EACAC,EACAC,EACAC,EACA,CACA,KAAK,QAAUH,EACf,KAAK,GAAKC,EACV,KAAK,GAAKC,EACV,KAAK,SAAWC,EAChB,KAAK,eAAiB,IAAI,IAG1B,KAAK,GAAG,iBAAiB,UAAYC,GAAM,CAEzC,IAAMC,EAAOD,EAAE,KAIf,KAAK,eAAe,QAASE,GAAa,CACxCA,EAASD,CAAI,CACf,CAAC,CACH,CAAC,CACH,CAGA,OAAc,CACZ,QAAQ,IAAI,2BAA2B,EAEnC,KAAK,UACP,KAAK,SAAS,KAAK,EAGjB,KAAK,IACP,KAAK,GAAG,MAAM,EAGZ,KAAK,IACP,KAAK,GAAG,MAAM,CAElB,CAGA,IAAI,QAAiB,CACnB,OAAO,KAAK,QAAQ,MACtB,CAEA,IAAI,OAAOE,EAAe,CACxB,KAAK,QAAQ,OAAS,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGA,CAAK,CAAC,CACtD,CAGA,IAAI,YAAsB,CACxB,OAAO,KAAK,QAAQ,KACtB,CAEA,IAAI,WAAWA,EAAgB,CAC7B,KAAK,QAAQ,MAAQA,CACvB,CAGA,IAAI,UAAoB,CACtB,MAAO,CAAC,KAAK,SAAS,OACxB,CAEA,IAAI,SAASA,EAAgB,CAC3B,KAAK,SAAS,QAAU,CAACA,CAC3B,CAGA,KAAKC,EAAkB,CACrB,QAAQ,IAAI,iBAAkBA,CAAK,EACnC,KAAK,GAAG,KAAK,KAAK,UAAUA,CAAK,CAAC,CACpC,CAEA,iBAAiBC,EAAYH,EAAqC,CAChE,KAAK,eAAe,IAAIG,EAAIH,CAAQ,CACtC,CAEA,oBAAoBG,EAAkB,CACpC,KAAK,eAAe,OAAOA,CAAE,CAC/B,CAGA,iBAAoC,CAClC,OAAO,KAAK,OACd,CAEA,mBAAuC,CACrC,OAAO,KAAK,EACd,CAEA,gBAAiC,CAC/B,OAAO,KAAK,EACd,CAEA,oBAAuC,CACrC,OAAO,KAAK,QACd,CACF,ECrGO,IAAMC,EAAN,MAAMA,CAAU,CAarB,YACEC,EACQC,EACR,CADQ,kBAAAA,EAVV,KAAQ,MAAiB,GACzB,KAAQ,YAA6B,KACrC,KAAQ,iBAA4B,GACpC,KAAQ,kBAA6B,GASnC,KAAK,QAAUD,EAGf,KAAK,QAAQ,iBAAiB,YAAa,IAAM,KAAK,WAAW,CAAC,EAClE,KAAK,QAAQ,iBAAiB,aAAc,IAAM,KAAK,WAAW,CAAC,EACnE,KAAK,QAAQ,cAAc,iBAAiB,UAAYE,GAAM,CACxDA,EAAE,MAAQ,KAAO,CAACA,EAAE,SACtBA,EAAE,eAAe,EACjB,KAAK,WAAW,EAEpB,CAAC,EAED,KAAK,QAAQ,iBAAiB,UAAW,IAAM,KAAK,SAAS,CAAC,EAC9D,KAAK,QAAQ,iBAAiB,WAAY,IAAM,KAAK,SAAS,CAAC,EAC/D,KAAK,QAAQ,cAAc,iBAAiB,QAAUA,GAAM,CACtDA,EAAE,MAAQ,KACZ,KAAK,SAAS,CAElB,CAAC,EAED,KAAK,QAAQ,iBAAiB,QAAUA,GAAM,KAAK,QAAQA,CAAC,CAAC,CAC/D,CAKO,SAAmB,CACxB,OAAO,KAAK,KACd,CAEO,oBAA8B,CACnC,OAAO,KAAK,gBACd,CAEO,SAASC,EAAsB,CAChC,KAAK,QAAUA,IAEnB,KAAK,MAAQA,EACb,KAAK,aAAaA,CAAK,EACzB,CAMO,iBAAwB,CAC7B,KAAK,iBAAmB,GACxB,KAAK,SAAS,EAAK,CACrB,CAEO,gBAAuB,CACxB,KAAK,mBACP,KAAK,iBAAmB,GACxB,KAAK,SAAS,EAAI,EAEtB,CAKO,QAAe,CACpB,KAAK,SAAS,CAAC,KAAK,KAAK,CAC3B,CAQQ,YAAmB,CAEzB,KAAK,YAAc,OAAO,WAAW,IAAM,CACzC,KAAK,gBAAgB,EACrB,KAAK,YAAc,IACrB,EAAGJ,EAAU,UAAU,CACzB,CAKQ,UAAiB,CACvB,KAAK,kBAAoB,GACzB,OAAO,WAAW,IAAM,CACtB,KAAK,kBAAoB,EAC3B,EAAG,CAAC,EAEA,KAAK,aAEP,aAAa,KAAK,WAAW,EAC7B,KAAK,YAAc,KACnB,KAAK,OAAO,GAGZ,KAAK,eAAe,CAExB,CAQQ,QAAQ,EAAqB,CACnC,GAAI,KAAK,kBAAmB,CAC1B,EAAE,eAAe,EACjB,EAAE,yBAAyB,EAC3B,MACF,CACA,KAAK,OAAO,CACd,CACF,EAjIaA,EAEK,WAAa,IAFxB,IAAMK,EAANL,ECAP,eAAsBM,EAAeC,EAAsBC,EAAe,CAExE,IAAMC,EAAK,IAAI,kBAGTC,EAAU,SAAS,cAAc,OAAO,EAC9CA,EAAQ,SAAW,GAEnBD,EAAG,QAAWE,GAAOD,EAAQ,UAAYC,EAAE,QAAQ,CAAC,EAMpD,IAAMC,GAHK,MAAM,UAAU,aAAa,aAAa,CACnD,MAAO,EACT,CAAC,GACmB,UAAU,EAAE,CAAC,EACjCH,EAAG,SAASG,CAAQ,EACpBA,EAAS,QAAU,GAGnB,IAAMC,EAAKJ,EAAG,kBAAkB,YAAY,EAGtCK,EAAQ,MAAML,EAAG,YAAY,EACnC,MAAMA,EAAG,oBAAoBK,CAAK,EAYlC,IAAMC,EAAoC,CACxC,KAAM,SACN,IAAK,MAXa,MAAM,MAAM,kDAAoBP,CAAK,GAAI,CAC3D,OAAQ,OACR,KAAMM,EAAM,IACZ,QAAS,CACP,cAAe,UAAUP,CAAY,GACrC,eAAgB,iBAClB,CACF,CAAC,GAIwB,KAAK,CAC9B,EACA,aAAME,EAAG,qBAAqBM,CAAM,EAG7B,IAAIC,EAAWN,EAASD,EAAII,EAAID,CAAQ,CACjD,CAGA,IAAMK,EAAN,cAA8B,MAAM,aAAc,CAChD,KAAKC,EAAO,CACV,OAAO,EAAEA,CAAK,EAAE,KAAK,gBAAgB,CACvC,CAEA,YAAYC,EAAIC,EAAM,CACpB,IAAMC,EAAK,KAAK,MAAMF,CAAE,EAGlB,CAAE,IAAAG,EAAK,MAAAd,CAAM,EAAI,KAAK,MAAMY,CAAI,EAClCG,EAAoBjB,EAAegB,EAAKd,CAAK,EAAE,KAAMgB,GAAe,CACtE,EAAE,QAAQ,EAAE,GAAG,qBAAsB,UAAY,CAC/C,QAAQ,IAAI,wDAAwD,EACpEA,EAAW,MAAM,CACnB,CAAC,EAKD,IAAMC,EAAmBN,EAAG,cAC1B,iBACF,EACMO,EAAY,IAAIC,EAAUF,EAAmBG,GAAmB,CAEpEJ,EAAW,SAAWI,EAElBA,GACFH,EAAiB,UAAU,OAAO,SAAU,YAAY,EACxDA,EAAiB,UAAU,IAAI,eAAe,IAE9CA,EAAiB,UAAU,OAAO,eAAe,EACjDA,EAAiB,UAAU,IAAI,SAAU,YAAY,EAEzD,CAAC,EAED,SAAEN,CAAE,EAAE,KAAK,eAAgBK,CAAU,EAGrCA,EAAW,iBAAiB,QAAUJ,GAAS,CAC7C,MAAM,cAAcC,EAAK,SAAUD,EAAM,CAAE,SAAU,OAAQ,CAAC,CAChE,CAAC,EAGD,MAAM,wBAAwB,gBAAkBS,GAAW,CACzDA,EAAO,QAASC,GAAUN,EAAW,KAAKM,CAAK,CAAC,CAClD,CAAC,EAEMN,CACT,CAAC,CACH,CAGA,YAAYL,EAAI,CACd,IAAMK,EAAa,EAAEL,CAAE,EAAE,KAAK,cAAc,EACxCK,GAAc,OAAOA,EAAW,OAAU,aAC5C,QAAQ,IAAI,sDAAsD,EAClEA,EAAW,MAAM,EAErB,CACF,EAGA,MAAM,eAAe,SAAS,IAAIP,EAAmB,iBAAiB,EAGtE,MAAM,wBACJ,aACA,CAAC,CAAE,SAAAc,CAAS,IAA4B,CACtC,IAAMrB,EAAU,SAAS,cAAcqB,CAAQ,EAC3CrB,GACFA,EAAQ,YAAc,EACtBA,EAAQ,KAAK,EAAE,MAAOsB,GAAQ,CAC5B,QAAQ,MAAM,uBAAwBA,CAAG,CAC3C,CAAC,GAED,QAAQ,MAAM,wCAAyCD,CAAQ,CAEnE,CACF",
  "names": ["Connection", "audioElement", "peerConnection", "dataChannel", "micTrack", "e", "data", "callback", "value", "event", "id", "_MicButton", "element", "onMuteChange", "e", "muted", "MicButton", "openConnection", "ephemeralKey", "model", "pc", "audioEl", "e", "micTrack", "dc", "offer", "answer", "Connection", "RealtimeBinding", "scope", "el", "data", "id", "key", "connectionPromise", "connection", "micButtonElement", "micButton", "MicButton", "muted", "events", "event", "selector", "err"]
}
