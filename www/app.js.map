{
  "version": 3,
  "sources": ["../src/MicButton.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * MicButton - Abstracts microphone button state management\n * \n * Manages state for mute/unmute and push-to-talk functionality\n */\nexport class MicButton {\n  // Constants\n  static readonly HOLD_DELAY = 200; // ms to differentiate between click and hold\n\n  // State\n  private muted: boolean = true;\n  private holdTimeout: number | null = null;\n  private pushToTalkActive: boolean = false;\n  private suppressNextClick: boolean = false;\n\n  // DOM elements\n  private element: HTMLElement;\n\n  constructor(\n    element: HTMLElement,\n    private onMuteChange: (muted: boolean) => void\n  ) {\n    this.element = element;\n\n    // Add event handlers\n    this.element.addEventListener(\"mousedown\", () => this.startPress());\n    this.element.addEventListener(\"touchstart\", () => this.startPress());\n    this.element.ownerDocument.addEventListener(\"keydown\", (e) => {\n      if (e.key === \" \" && !e.repeat) {\n        e.preventDefault(); // Prevent page scrolling\n        this.startPress();\n      }\n    });\n\n    this.element.addEventListener(\"mouseup\", () => this.endPress());\n    this.element.addEventListener(\"touchend\", () => this.endPress());\n    this.element.ownerDocument.addEventListener(\"keyup\", (e) => {\n      if (e.key === \" \") {\n        this.endPress();\n      }\n    });\n\n    this.element.addEventListener(\"click\", (e) => this.onClick(e));\n  }\n\n  /**\n   * Getters & Setters\n   */\n  public isMuted(): boolean {\n    return this.muted;\n  }\n\n  public isPushToTalkActive(): boolean {\n    return this.pushToTalkActive;\n  }\n\n  public setMuted(muted: boolean): void {\n    if (this.muted === muted) return;\n\n    this.muted = muted;\n    this.onMuteChange(muted);\n  }\n\n  /**\n   * Push-to-talk methods. Call these only when we are sure the user is holding\n   * the button or key down, not a momentary click/press.\n   */\n  public startPushToTalk(): void {\n    this.pushToTalkActive = true;\n    this.setMuted(false);\n  }\n\n  public stopPushToTalk(): void {\n    if (this.pushToTalkActive) {\n      this.pushToTalkActive = false;\n      this.setMuted(true);\n    }\n  }\n\n  /**\n   * Toggle mute/unmute state\n   */\n  public toggle(): void {\n    this.setMuted(!this.muted);\n  }\n\n  /**\n   * Begin the gesture that may turn out to be a click (toggle), or may turn out\n   * to be a hold (push-to-talk).\n   *\n   * It's the same logic for mouse, touch, and space key.\n   */\n  private startPress(): void {\n    // Do nothing at first--we don't know if it's a click or hold\n    this.holdTimeout = window.setTimeout(() => {\n      this.startPushToTalk();\n      this.holdTimeout = null;\n    }, MicButton.HOLD_DELAY);\n  }\n\n  /**\n   * End the gesture that may have been a click or a hold.\n   */\n  private endPress(): void {\n    this.suppressNextClick = true;\n    window.setTimeout(() => {\n      this.suppressNextClick = false;\n    }, 0);\n\n    if (this.holdTimeout) {\n      // It was a click\n      clearTimeout(this.holdTimeout);\n      this.holdTimeout = null;\n      this.toggle();\n    } else {\n      // It was a hold\n      this.stopPushToTalk();\n    }\n  }\n\n  /**\n   * We generally don't need this; it's only for programmatic clicks (e.g. from\n   * screen readers, or possibly JS). We suppress it if it was preceded by a\n   * mousedown/touchstart/keydown because we would've already performed the\n   * desired action then.\n   */\n  private onClick(e: MouseEvent): void {\n    if (this.suppressNextClick) {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n      return;\n    }\n    this.toggle();\n  }\n}\n", "import \"./binding\";\nimport { MicButton } from \"./MicButton\";\nimport \"./styles.css\";\n\nexport async function openConnection(ephemeralKey: string) {\n  // Create a peer connection\n  const pc = new RTCPeerConnection();\n\n  // Set up to play remote audio from the model\n  const audioEl = document.createElement(\"audio\");\n  audioEl.autoplay = true;\n\n  pc.ontrack = (e) => (audioEl.srcObject = e.streams[0]);\n\n  // Add local audio track for microphone input in the browser\n  const ms = await navigator.mediaDevices.getUserMedia({\n    audio: true,\n  });\n  const micTrack = ms.getTracks()[0];\n  pc.addTrack(micTrack);\n  micTrack.enabled = false; // Start with mic muted\n\n  // Set up data channel for sending and receiving events\n  const dc = pc.createDataChannel(\"oai-events\");\n\n  // Event listeners for data channel\n  const eventListeners = new Map();\n\n  dc.addEventListener(\"message\", (e) => {\n    // Notify all registered event listeners\n    const data = e.data;\n    console.log(\"Received event:\", data);\n\n    // Dispatch event to all registered handlers\n    eventListeners.forEach((callback) => {\n      callback(data);\n    });\n  });\n\n  // Start the session using the Session Description Protocol (SDP)\n  const offer = await pc.createOffer();\n  await pc.setLocalDescription(offer);\n\n  const baseUrl = \"https://api.openai.com/v1/realtime\";\n  const model = \"gpt-4o-realtime-preview-2025-06-03\";\n  const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {\n    method: \"POST\",\n    body: offer.sdp,\n    headers: {\n      Authorization: `Bearer ${ephemeralKey}`,\n      \"Content-Type\": \"application/sdp\",\n    },\n  });\n\n  const answer: RTCSessionDescriptionInit = {\n    type: \"answer\",\n    sdp: await sdpResponse.text(),\n  };\n  await pc.setRemoteDescription(answer);\n\n  // Create the connection object with getters/setters for properties\n  const connection = {\n    // Cleanup method to terminate the connection\n    close: () => {\n      console.log(\"Closing WebRTC connection\");\n      // Clean up tracks\n      if (micTrack) {\n        micTrack.stop();\n      }\n      // Close data channel\n      if (dc) {\n        dc.close();\n      }\n      // Close peer connection\n      if (pc) {\n        pc.close();\n      }\n    },\n\n    // Volume property (0.0 - 1.0)\n    get volume() {\n      return audioEl.volume;\n    },\n    set volume(value: number) {\n      audioEl.volume = Math.max(0, Math.min(1, value));\n    },\n\n    // Speaker muted property\n    get audioMuted() {\n      return audioEl.muted;\n    },\n    set audioMuted(value: boolean) {\n      audioEl.muted = value;\n    },\n\n    // Microphone muted property\n    get micMuted() {\n      return !micTrack.enabled;\n    },\n    set micMuted(value: boolean) {\n      micTrack.enabled = !value;\n    },\n\n    // Data channel method\n    send: (event: any) => {\n      console.log(\"Sending event:\", event);\n      dc.send(JSON.stringify(event));\n    },\n    addEventListener: (id: string, callback: (data: any) => void) => {\n      eventListeners.set(id, callback);\n    },\n    removeEventListener: (id: string) => {\n      eventListeners.delete(id);\n    },\n\n    // Expose elements for advanced use cases\n    getAudioElement: () => audioEl,\n    getPeerConnection: () => pc,\n    getDataChannel: () => dc,\n    getMicrophoneTrack: () => micTrack,\n  };\n\n  return connection;\n}\n\n// Custom Shiny output binding for real-time display\nvar realtimeBinding = new Shiny.OutputBinding();\n\n$.extend(realtimeBinding, {\n  find: function (scope) {\n    return $(scope).find(\".shinyrealtime\");\n  },\n\n  renderValue: function (el, data) {\n    const id = this.getId(el);\n\n    // Store connection in element data for cleanup\n    let connectionPromise = openConnection(data).then((connection) => {\n      $(document).on(\"shiny:disconnected\", function () {\n        console.log(\"Shiny disconnected, cleaning up any WebRTC connections\");\n        connection.close();\n      });\n\n      // MicButton implementation has been moved to MicButton.ts\n\n      // Create the mic button controller\n      const micButtonElement = el.querySelector(\n        \".mic-toggle-btn\"\n      ) as HTMLElement;\n      const micButton = new MicButton(micButtonElement, (muted: boolean) => {\n        // This is our callback when mic state changes\n        connection.micMuted = muted;\n\n        if (muted) {\n          micButtonElement.classList.remove(\"active\", \"btn-danger\");\n          micButtonElement.classList.add(\"btn-secondary\");\n        } else {\n          micButtonElement.classList.remove(\"btn-secondary\");\n          micButtonElement.classList.add(\"active\", \"btn-danger\");\n        }\n      });\n\n      $(el).data(\"rtConnection\", connection);\n\n      // Set up Shiny-specific event handling\n      connection.addEventListener(\"shiny\", (data) => {\n        Shiny.setInputValue(id + \"_event\", data, { priority: \"event\" });\n      });\n\n      // Set up message handler for sending events from Shiny\n      Shiny.addCustomMessageHandler(\"realtime_send\", (events) => {\n        if (Array.isArray(events)) {\n          events.forEach((event) => connection.send(event));\n        } else {\n          connection.send(events);\n        }\n      });\n\n      return connection;\n    });\n  },\n\n  // Clean up connection when element is removed/updated\n  unsubscribe: function (el) {\n    const connection = $(el).data(\"rtConnection\");\n    if (connection && typeof connection.close === \"function\") {\n      console.log(\"Closing WebRTC connection due to element unsubscribe\");\n      connection.close();\n    }\n  },\n});\n\n// Register the binding\nShiny.outputBindings.register(realtimeBinding, \"realtime-output\");\n"],
  "mappings": "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",
  "names": ["data"]
}
