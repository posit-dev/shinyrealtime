{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import \"./binding\";\nimport \"./styles.css\";\n\nexport async function openConnection(ephemeralKey: string) {\n  // Create a peer connection\n  const pc = new RTCPeerConnection();\n\n  // Set up to play remote audio from the model\n  const audioEl = document.createElement(\"audio\");\n  audioEl.autoplay = true;\n\n  pc.ontrack = (e) => (audioEl.srcObject = e.streams[0]);\n\n  // Add local audio track for microphone input in the browser\n  const ms = await navigator.mediaDevices.getUserMedia({\n    audio: true,\n  });\n  const micTrack = ms.getTracks()[0];\n  pc.addTrack(micTrack);\n  micTrack.enabled = false; // Start with mic muted\n\n  // Set up data channel for sending and receiving events\n  const dc = pc.createDataChannel(\"oai-events\");\n\n  // Event listeners for data channel\n  const eventListeners = new Map();\n\n  dc.addEventListener(\"message\", (e) => {\n    // Notify all registered event listeners\n    const data = e.data;\n    console.log(\"Received event:\", data);\n\n    // Dispatch event to all registered handlers\n    eventListeners.forEach((callback) => {\n      callback(data);\n    });\n  });\n\n  // Start the session using the Session Description Protocol (SDP)\n  const offer = await pc.createOffer();\n  await pc.setLocalDescription(offer);\n\n  const baseUrl = \"https://api.openai.com/v1/realtime\";\n  const model = \"gpt-4o-realtime-preview-2025-06-03\";\n  const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {\n    method: \"POST\",\n    body: offer.sdp,\n    headers: {\n      Authorization: `Bearer ${ephemeralKey}`,\n      \"Content-Type\": \"application/sdp\",\n    },\n  });\n\n  const answer: RTCSessionDescriptionInit = {\n    type: \"answer\",\n    sdp: await sdpResponse.text(),\n  };\n  await pc.setRemoteDescription(answer);\n\n  // Create the connection object with getters/setters for properties\n  const connection = {\n    // Cleanup method to terminate the connection\n    close: () => {\n      console.log(\"Closing WebRTC connection\");\n      // Clean up tracks\n      if (micTrack) {\n        micTrack.stop();\n      }\n      // Close data channel\n      if (dc) {\n        dc.close();\n      }\n      // Close peer connection\n      if (pc) {\n        pc.close();\n      }\n    },\n\n    // Volume property (0.0 - 1.0)\n    get volume() {\n      return audioEl.volume;\n    },\n    set volume(value: number) {\n      audioEl.volume = Math.max(0, Math.min(1, value));\n    },\n\n    // Speaker muted property\n    get audioMuted() {\n      return audioEl.muted;\n    },\n    set audioMuted(value: boolean) {\n      audioEl.muted = value;\n    },\n\n    // Microphone muted property\n    get micMuted() {\n      return !micTrack.enabled;\n    },\n    set micMuted(value: boolean) {\n      micTrack.enabled = !value;\n    },\n\n    // Data channel method\n    send: (event: any) => {\n      console.log(\"Sending event:\", event);\n      dc.send(JSON.stringify(event));\n    },\n    addEventListener: (id: string, callback: (data: any) => void) => {\n      eventListeners.set(id, callback);\n    },\n    removeEventListener: (id: string) => {\n      eventListeners.delete(id);\n    },\n\n    // Expose elements for advanced use cases\n    getAudioElement: () => audioEl,\n    getPeerConnection: () => pc,\n    getDataChannel: () => dc,\n    getMicrophoneTrack: () => micTrack,\n  };\n\n  return connection;\n}\n\n// Custom Shiny output binding for real-time display\nvar realtimeBinding = new Shiny.OutputBinding();\n\n$.extend(realtimeBinding, {\n  find: function (scope) {\n    return $(scope).find(\".shinyrealtime\");\n  },\n\n  renderValue: function (el, data) {\n    const id = this.getId(el);\n\n    // Store connection in element data for cleanup\n    let connectionPromise = openConnection(data).then((connection) => {\n      $(document).on(\"shiny:disconnected\", function () {\n        console.log(\"Shiny disconnected, cleaning up any WebRTC connections\");\n        connection.close();\n      });\n\n      $(el).find(\".btn-unmute\").show();\n      \n      // Track whether we're in push-to-talk mode\n      let isHoldingMic = false;\n      let holdTimeout: number | null = null;\n      const holdDelay = 200; // ms to differentiate between click and hold\n      \n      // Handle mousedown/touchstart for push-to-talk\n      $(el).on(\"mousedown touchstart\", \".btn-mute, .btn-unmute\", function(this: HTMLElement, event: any) {\n        // Clear any existing timeout\n        if (holdTimeout !== null) {\n          clearTimeout(holdTimeout);\n        }\n        \n        // Set a timeout to determine if this is a hold or a click\n        holdTimeout = window.setTimeout(() => {\n          isHoldingMic = true;\n          // Only unmute if we're pressing the unmute button\n          if ($(event.target).closest(\".btn-unmute\").length > 0) {\n            connection.micMuted = false; // Unmute for push-to-talk\n            $(el).find(\".btn-unmute\").hide();\n            $(el).find(\".btn-mute\").show();\n          }\n        }, holdDelay);\n      });\n      \n      // Handle mouseup/touchend for push-to-talk\n      $(document).on(\"mouseup touchend\", function(this: HTMLElement, event: any) {\n        // Clear the timeout if it's still pending\n        if (holdTimeout !== null) {\n          clearTimeout(holdTimeout);\n          holdTimeout = null;\n        }\n        \n        // If we were holding the mic button, handle push-to-talk release\n        if (isHoldingMic) {\n          isHoldingMic = false;\n          // Re-mute the mic when released\n          connection.micMuted = true;\n          $(el).find(\".btn-mute\").hide();\n          $(el).find(\".btn-unmute\").show();\n          \n          // Prevent click from firing after a hold\n          event.stopPropagation();\n          return false;\n        }\n      });\n      \n      // Regular click handlers for toggle behavior\n      $(el).on(\"click\", \".btn-mute\", function() {\n        // Skip if we're in push-to-talk mode\n        if (isHoldingMic) return;\n        \n        connection.micMuted = true;\n        $(el).find(\".btn-mute\").hide();\n        $(el).find(\".btn-unmute\").show();\n      });\n      \n      $(el).on(\"click\", \".btn-unmute\", function() {\n        // Skip if we're in push-to-talk mode\n        if (isHoldingMic) return;\n        \n        connection.micMuted = false;\n        $(el).find(\".btn-unmute\").hide();\n        $(el).find(\".btn-mute\").show();\n      });\n\n      $(el).data(\"rtConnection\", connection);\n\n      // Set up Shiny-specific event handling\n      connection.addEventListener(\"shiny\", (data) => {\n        Shiny.setInputValue(id + \"_event\", data, { priority: \"event\" });\n      });\n\n      // Set up message handler for sending events from Shiny\n      Shiny.addCustomMessageHandler(\"realtime_send\", (events) => {\n        if (Array.isArray(events)) {\n          events.forEach((event) => connection.send(event));\n        } else {\n          connection.send(events);\n        }\n      });\n\n      return connection;\n    });\n  },\n\n  // Clean up connection when element is removed/updated\n  unsubscribe: function (el) {\n    const connection = $(el).data(\"rtConnection\");\n    if (connection && typeof connection.close === \"function\") {\n      console.log(\"Closing WebRTC connection due to element unsubscribe\");\n      connection.close();\n    }\n  },\n});\n\n// Register the binding\nShiny.outputBindings.register(realtimeBinding, \"realtime-output\");\n"],
  "mappings": "mBAGA,eAAsBA,EAAeC,EAAsB,CAEzD,IAAMC,EAAK,IAAI,kBAGTC,EAAU,SAAS,cAAc,OAAO,EAC9CA,EAAQ,SAAW,GAEnBD,EAAG,QAAWE,GAAOD,EAAQ,UAAYC,EAAE,QAAQ,CAAC,EAMpD,IAAMC,GAHK,MAAM,UAAU,aAAa,aAAa,CACnD,MAAO,EACT,CAAC,GACmB,UAAU,EAAE,CAAC,EACjCH,EAAG,SAASG,CAAQ,EACpBA,EAAS,QAAU,GAGnB,IAAMC,EAAKJ,EAAG,kBAAkB,YAAY,EAGtCK,EAAiB,IAAI,IAE3BD,EAAG,iBAAiB,UAAYF,GAAM,CAEpC,IAAMI,EAAOJ,EAAE,KACf,QAAQ,IAAI,kBAAmBI,CAAI,EAGnCD,EAAe,QAASE,GAAa,CACnCA,EAASD,CAAI,CACf,CAAC,CACH,CAAC,EAGD,IAAME,EAAQ,MAAMR,EAAG,YAAY,EACnC,MAAMA,EAAG,oBAAoBQ,CAAK,EAalC,IAAMC,EAAoC,CACxC,KAAM,SACN,IAAK,MAXa,MAAM,MAAM,8EAA6B,CAC3D,OAAQ,OACR,KAAMD,EAAM,IACZ,QAAS,CACP,cAAe,UAAUT,CAAY,GACrC,eAAgB,iBAClB,CACF,CAAC,GAIwB,KAAK,CAC9B,EACA,aAAMC,EAAG,qBAAqBS,CAAM,EAGjB,CAEjB,MAAO,IAAM,CACX,QAAQ,IAAI,2BAA2B,EAEnCN,GACFA,EAAS,KAAK,EAGZC,GACFA,EAAG,MAAM,EAGPJ,GACFA,EAAG,MAAM,CAEb,EAGA,IAAI,QAAS,CACX,OAAOC,EAAQ,MACjB,EACA,IAAI,OAAOS,EAAe,CACxBT,EAAQ,OAAS,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGS,CAAK,CAAC,CACjD,EAGA,IAAI,YAAa,CACf,OAAOT,EAAQ,KACjB,EACA,IAAI,WAAWS,EAAgB,CAC7BT,EAAQ,MAAQS,CAClB,EAGA,IAAI,UAAW,CACb,MAAO,CAACP,EAAS,OACnB,EACA,IAAI,SAASO,EAAgB,CAC3BP,EAAS,QAAU,CAACO,CACtB,EAGA,KAAOC,GAAe,CACpB,QAAQ,IAAI,iBAAkBA,CAAK,EACnCP,EAAG,KAAK,KAAK,UAAUO,CAAK,CAAC,CAC/B,EACA,iBAAkB,CAACC,EAAYL,IAAkC,CAC/DF,EAAe,IAAIO,EAAIL,CAAQ,CACjC,EACA,oBAAsBK,GAAe,CACnCP,EAAe,OAAOO,CAAE,CAC1B,EAGA,gBAAiB,IAAMX,EACvB,kBAAmB,IAAMD,EACzB,eAAgB,IAAMI,EACtB,mBAAoB,IAAMD,CAC5B,CAGF,CAGA,IAAIU,EAAkB,IAAI,MAAM,cAEhC,EAAE,OAAOA,EAAiB,CACxB,KAAM,SAAUC,EAAO,CACrB,OAAO,EAAEA,CAAK,EAAE,KAAK,gBAAgB,CACvC,EAEA,YAAa,SAAUC,EAAIT,EAAM,CAC/B,IAAMM,EAAK,KAAK,MAAMG,CAAE,EAGpBC,EAAoBlB,EAAeQ,CAAI,EAAE,KAAMW,GAAe,CAChE,EAAE,QAAQ,EAAE,GAAG,qBAAsB,UAAY,CAC/C,QAAQ,IAAI,wDAAwD,EACpEA,EAAW,MAAM,CACnB,CAAC,EAED,EAAEF,CAAE,EAAE,KAAK,aAAa,EAAE,KAAK,EAG/B,IAAIG,EAAe,GACfC,EAA6B,KAC3BC,EAAY,IAGlB,SAAEL,CAAE,EAAE,GAAG,uBAAwB,yBAA0B,SAA4BJ,EAAY,CAE7FQ,IAAgB,MAClB,aAAaA,CAAW,EAI1BA,EAAc,OAAO,WAAW,IAAM,CACpCD,EAAe,GAEX,EAAEP,EAAM,MAAM,EAAE,QAAQ,aAAa,EAAE,OAAS,IAClDM,EAAW,SAAW,GACtB,EAAEF,CAAE,EAAE,KAAK,aAAa,EAAE,KAAK,EAC/B,EAAEA,CAAE,EAAE,KAAK,WAAW,EAAE,KAAK,EAEjC,EAAGK,CAAS,CACd,CAAC,EAGD,EAAE,QAAQ,EAAE,GAAG,mBAAoB,SAA4BT,EAAY,CAQzE,GANIQ,IAAgB,OAClB,aAAaA,CAAW,EACxBA,EAAc,MAIZD,EACF,OAAAA,EAAe,GAEfD,EAAW,SAAW,GACtB,EAAEF,CAAE,EAAE,KAAK,WAAW,EAAE,KAAK,EAC7B,EAAEA,CAAE,EAAE,KAAK,aAAa,EAAE,KAAK,EAG/BJ,EAAM,gBAAgB,EACf,EAEX,CAAC,EAGD,EAAEI,CAAE,EAAE,GAAG,QAAS,YAAa,UAAW,CAEpCG,IAEJD,EAAW,SAAW,GACtB,EAAEF,CAAE,EAAE,KAAK,WAAW,EAAE,KAAK,EAC7B,EAAEA,CAAE,EAAE,KAAK,aAAa,EAAE,KAAK,EACjC,CAAC,EAED,EAAEA,CAAE,EAAE,GAAG,QAAS,cAAe,UAAW,CAEtCG,IAEJD,EAAW,SAAW,GACtB,EAAEF,CAAE,EAAE,KAAK,aAAa,EAAE,KAAK,EAC/B,EAAEA,CAAE,EAAE,KAAK,WAAW,EAAE,KAAK,EAC/B,CAAC,EAED,EAAEA,CAAE,EAAE,KAAK,eAAgBE,CAAU,EAGrCA,EAAW,iBAAiB,QAAUX,GAAS,CAC7C,MAAM,cAAcM,EAAK,SAAUN,EAAM,CAAE,SAAU,OAAQ,CAAC,CAChE,CAAC,EAGD,MAAM,wBAAwB,gBAAkBe,GAAW,CACrD,MAAM,QAAQA,CAAM,EACtBA,EAAO,QAASV,GAAUM,EAAW,KAAKN,CAAK,CAAC,EAEhDM,EAAW,KAAKI,CAAM,CAE1B,CAAC,EAEMJ,CACT,CAAC,CACH,EAGA,YAAa,SAAUF,EAAI,CACzB,IAAME,EAAa,EAAEF,CAAE,EAAE,KAAK,cAAc,EACxCE,GAAc,OAAOA,EAAW,OAAU,aAC5C,QAAQ,IAAI,sDAAsD,EAClEA,EAAW,MAAM,EAErB,CACF,CAAC,EAGD,MAAM,eAAe,SAASJ,EAAiB,iBAAiB",
  "names": ["openConnection", "ephemeralKey", "pc", "audioEl", "e", "micTrack", "dc", "eventListeners", "data", "callback", "offer", "answer", "value", "event", "id", "realtimeBinding", "scope", "el", "connectionPromise", "connection", "isHoldingMic", "holdTimeout", "holdDelay", "events"]
}
