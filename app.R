library(bslib)
library(dotenv)
library(ellmer)
library(shiny)
library(shinychat)
library(shinyrealtime)
library(dplyr)
library(ggplot2)
library(dotty)

Sys.setenv("RETICULATE_PYTHON" = "managed")
reticulate::py_require(c(
  "matplotlib",
  "pandas",
  "plotnine",
  "seaborn"
))


py_run_string_and_draw_matplotlib <- function(code, dpi = 96) {
  ## eval Python code, size matplotlib current figure to temp png, draw png on R graphics device

  # clear any previous matplotlib state
  reticulate::py_run_string(
    "import matplotlib; matplotlib.pyplot.close('all'); matplotlib.use('agg', force=True)",
    local = TRUE
  )

  # run the code
  reticulate::py_run_string(code, local = TRUE)

  # fetch the matplotlib figure, save as png
  img_path <- tempfile("reticulate-matplotlib-plot-", fileext = ".png")
  on.exit(unlink(img_path))

  .[width_in, height_in] <- dev.size(units = "in")
  save_img_code <- glue::glue(
    r"---(
    import matplotlib.pyplot as plt
    fig = plt.gcf()
    fig.set_dpi({dpi})
    fig.set_size_inches({width_in}, {height_in})
    fig.savefig(r'''{img_path}''', dpi={dpi})
    plt.close('all')
    )---"
  )
  reticulate::py_run_string(save_img_code, local = TRUE)

  # Draw png onto the R device
  img <- png::readPNG(img_path, native = TRUE)
  par(mar = c(0, 0, 0, 0))
  plot.new()
  plot.window(xlim = 0:1, ylim = 0:1, xaxs = "i", yaxs = "i")
  rasterImage(img, 0, 0, 1, 1, interpolate = FALSE)
  invisible()
}

# warmup the Python code path to avoid the initialization delay later
withr::with_tempfile("warmup.png", {
  withr::with_png("warmup.png", {
    py_run_string_and_draw_matplotlib(glue::trim(
      '
      from plotnine import * 
      from plotnine.data import anscombe_quartet 
      
      plot = ggplot(anscombe_quartet, aes(x="x", y="y")) + geom_point()
      plot.show()
      '
    ))
  })
})


# Read prompt file
prompt <- readLines("prompt-r.md") |> paste(collapse = "\n")

# Load example datasets
samples <- list()
for (dataset in c("mpg", "diamonds", "economics", "iris", "mtcars")) {
  df <- eval(parse(text = dataset))
  if (is.data.frame(df)) {
    samples <- c(
      samples,
      paste0(
        "## ",
        dataset,
        "\n\n",
        capture.output(write.csv(head(df), "")),
        collapse = "\n"
      )
    )
  }
}

prompt <- paste0(
  prompt,
  "\n\n# Available Datasets\n\n",
  paste(samples, collapse = "\n\n")
)

hidden_audio_el <- function(id, file_path, media_type = "audio/mp3") {
  raw_data <- readBin(file_path, "raw", file.info(file_path)$size)
  base64_data <- base64enc::base64encode(raw_data)
  data_uri <- paste0("data:", media_type, ";base64,", base64_data)
  tags$audio(id = id, src = data_uri, style = "display:none;", preload = "auto")
}


ui <- page_sidebar(
  title = "VoicePlot",
  fillable = TRUE,
  style = "--bslib-spacer: 1rem; padding-bottom: 0;",
  sidebar = sidebar(
    helpText("Session cost:", textOutput("session_cost", inline = TRUE)),
    output_markdown_stream("response_text")
  ),
  card(
    full_screen = TRUE,
    card_header("Plot"),
    card_body(padding = 0, plotOutput("plot", fill = TRUE)),
    height = "66%"
  ),
  layout_columns(
    height = "34%",
    card(
      full_screen = TRUE,
      card_header("Code"),
      verbatimTextOutput("code_text")
    )
  ),
  realtime_ui(
    "realtime1",
    style = "z-index: 100000; margin-left: auto; margin-right: auto;",
    right = NULL
  ),
  hidden_audio_el("shutter", "shutter.mp3")
)

server <- function(input, output, session) {
  last_code <- reactiveVal()
  running_cost <- reactiveVal(0) # Cost of tokens used in the session, in dollars

  greeting <- "Welcome to Shiny Realtime!\n\nYou're currently muted; click the mic button to unmute, click-and-hold the mic for push-to-talk, or hold the spacebar key for push-to-talk."

  append_transcript <- function(text, clear = FALSE) {
    markdown_stream(
      "response_text",
      coro::gen(yield(text)),
      operation = if (clear) "replace" else "append",
      session = session
    )
  }

  append_transcript(greeting, clear = TRUE)

  run_r_plot_code <- function(code) {
    last_code(code)
  }

  run_r_plot_code_tool <- ellmer::tool(
    run_r_plot_code,
    "Run R code that generates a static plot",
    arguments = list(
      code = type_string(
        "The R code to run that generates a plot. If using ggplot2, the last expression in the code should be the plot object, e.g. `p`."
      )
    )
  )

  run_py_plot_code <- function(code) {
    attr(code, "language") <- "python"
    last_code(code)
  }

  run_py_plot_code_tool <- ellmer::tool(
    run_py_plot_code,
    "Run Python code (matplotlib) that generates a static plot",
    arguments = list(
      code = type_string(
        "The Python code to run that generates a matplotlib figure. If using plotnine, the code should call `.show()` on the plot object."
      )
    )
  )

  realtime_controls <- realtime_server(
    "realtime1",
    voice = "cedar",
    instructions = prompt,
    tools = list(run_r_plot_code_tool, run_py_plot_code_tool),
    speed = 1.1
  )

  # Handle function call start - show notification
  realtime_controls$on("conversation.item.added", \(event) {
    if (event$item$type == "function_call") {
      shiny::showNotification(
        "Generating code, please wait...",
        id = event$item$id,
        closeButton = FALSE
      )
    }
  })

  # Handle function call completion - remove notification
  realtime_controls$on("conversation.item.done", \(event) {
    if (event$item$type == "function_call") {
      shiny::removeNotification(id = event$item$id)
    }
  })

  # Handle new messages - clear transcript
  realtime_controls$on("response.created", \(event) {
    append_transcript("", clear = TRUE)
  })

  # Handle text streaming
  realtime_controls$on("response.output_audio_transcript.delta", \(event) {
    append_transcript(event$delta)
  })

  realtime_controls$on("response.done", \(event) {
    # "usage": {
    #   "total_tokens": 1977,
    #   "input_tokens": 1687,
    #   "output_tokens": 290,
    #   "input_token_details": {
    #     "text_tokens": 1636,
    #     "audio_tokens": 51,
    #     "image_tokens": 0,
    #     "cached_tokens": 1600,
    #     "cached_tokens_details": {
    #       "text_tokens": 1600,
    #       "audio_tokens": 0,
    #       "image_tokens": 0
    #     }
    #   },
    #   "output_token_details": { "text_tokens": 68, "audio_tokens": 222 }
    # }
    usage <- event$response$usage
    current_response <- c(
      input_text = usage$input_token_details$text_tokens,
      input_audio = usage$input_token_details$audio_tokens,
      input_image = usage$input_token_details$image_tokens,
      input_text_cached = usage$input_token_details$cached_tokens_details$text_tokens,
      input_audio_cached = usage$input_token_details$cached_tokens_details$audio_tokens,
      input_image_cached = usage$input_token_details$cached_tokens_details$image_tokens,
      output_text = usage$output_token_details$text_tokens,
      output_audio = usage$output_token_details$audio_tokens
    )

    cost <- sum(current_response * pricing_gpt4_realtime)
    running_cost(isolate(running_cost()) + cost)
  })

  pricing_gpt4_realtime <- c(
    input_text = 4 / 1e6,
    input_audio = 32 / 1e6,
    input_image = 5 / 1e6,
    input_text_cached = 0.4 / 1e6,
    input_audio_cached = 0.4 / 1e6,
    input_image_cached = 0.5 / 1e6,
    output_text = 16 / 1e6,
    output_audio = 64 / 1e6
  )
  pricing_gpt_4o_mini <- c(
    input_text = 0.6 / 1e6,
    input_audio = 10 / 1e6,
    input_text_cached = 0.3 / 1e6,
    input_audio_cached = 0.3 / 1e6,
    output_text = 2.4 / 1e6,
    output_audio = 20 / 1e6
  )

  output$plot <- renderPlot(res = 96, execOnResize = TRUE, {
    req(last_code())

    code <- last_code()
    if (identical(attr(code, "language"), "python")) {
      py_run_string_and_draw_matplotlib(code, dpi = 96)
      result <- list(visible = FALSE, value = NULL)
    } else {
      result <- withVisible(eval(parse(text = code)))
    }
    session$sendCustomMessage("play_audio", list(selector = "#shutter"))
    if (result$visible) {
      result$value
    } else {
      invisible(result$value)
    }
  })

  output$code_text <- renderText({
    req(last_code())
    last_code()
  })

  output$session_cost <- renderText({
    paste0(sprintf("$%.4f", running_cost()))
  })
}

shinyApp(ui, server)
